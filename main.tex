\documentclass[14pt]{article}

\begin{document}

\section{Introduction}
A floating point number is a number that has a decimal point and thus can store a fractional value. These numbers are stored differently than integers because to store a floating point number there are mainly 2 challenges. First of all, there is a challenge of storing the integer part and also storing the fractional part, hence more memory. Secondly, there are infinitely many floating point numbers even in a finite range, for example $[0, 1]$. So the floating point representation has to be clever enough to allow floating point numbers in a large range, as well as support good enough precision.\\\\

The floating point number representation uses the scientific notation of numbers. It has 3 parts - sign, significand and exponent. There are many different standards that decide how many bits each of these segments should store.\\
The \textit{IEEE 754} standard specifies that there should be 1 sign bit, 8 exponent bits and 23 significand bits.\\
The exponent is not directly stored, rather it is \textit{biased} first by adding a bias to the actual exponent and than store that in memory. The significance of this process is to make the exponent unsigned, thus allowing easier circuitry to deal with the comparison of exponents of 2 numbers. The bias is chosen to be $2^{n-1}-1$ where $n$ is the number of bits in the exponent field.\\
In the scientific notation there is always a 1 in front of the radix point unless the number is 0. So storing that 1 is redundant, hence the significand bits always store the fractional part.

So the overall representation looks like: 
$$(-1)^{\textrm{sign}}\times(1 + \textrm{significand})\times2^{\textrm{exponent}-\textrm{bias}}$$
Here the \textit{exponent} portion represents the exponent stored in memory.\\\\

This representation has the power of encapsulating large range due to the use of exponents. On the other hand it can store numbers in great precision as effective exponents can be negative, and thus indicate really small numbers. But it should be kept in mind that there can be scenarios, specially for larger exponents, where the exact floating point number can not be stored. In those cases the memory stores the nearest floating point number.

\pagebreak

\section{Problem Specification}
The assignment asked to create a floating point adder circuit that takes 2 floating point numbers and calculates their sum, and also notifies if there was any overflow or underflow. The representation was defined in the following manner- \\

{
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Sign} & \textbf{Exponent} & \textbf{Significand}\\
		\hline
		1 bit & 11 bits & 20 bits\\
		\hline
	\end{tabular}\par
}

\section{Comprehensive Design Description}
Each high level module and how they work is listed below

\subsection{Multiplexers}
There are several multiplexer circuit each working with different input sizes. The multiplexers that were required for this assignment are - $5\times1$, $8\times1$, $28\times1$, $32\times1$. They were created by chaining several $74157$ MUX ICs.

\subsection{Shifters}\label{shifter_section}
In order to shift the numbers we needed different kind of shifters for both direction. In normalization and also in exponent-equalization, the numbers needed to be shifted by arbitrary amount. So shifters that can support arbitrary amount shifting were required.\\

Instead of making all possible shifters (1 bit shifter, 2 bit shifter, 3 bit shifter and so on..), the design was cleverly crafted so that there are lesser number of ICs used. Only 5 different shifters were created (1, 2, 4, 8 and 16). Each of them having 2 inputs - \textit{the number} and \textit{enable}. They are designed so that when the \textit{enable} is set to 1, the number is shifted by the amount specified by the module, otherwise the number is not changed and passed to the output. This \textit{enable} feature was achieved by introducing a MUX in the output so that when \textit{enable} is 1, the shifted number is sent to the output, otherwise the original number is sent to the output.\\

Now that the fixed amount of shifters (that can only shift by an amount that is a whole power of 2) are ready, we can finally create arbitrary shifters. The arbitrary right shifter (same logic for left shifter) takes 2 inputs - \textit{the number to shift} and \textit{the shift amount}. Since the shift amount is specified by a binary number, we can leverage the fact that in a binary number, each bit corresponds to the availability of a certain power of 2. So connecting each bit to the corresponding shifter's enable and chaining such shifters will suffice to shift by any arbitrary amount.

\subsubsection{Shift Adapter}
Since the exponents are 11 bits each, their difference will also be 11 bits. But we only have 5 shifters as described in Section \ref{shifter_section}. So we need some sort of an adapter that take the 11 bit difference and generate a suitable enable string for the right shifter. This adapter basically compares the highest possible enable value (for example it does not make sense to shift a 32 bit number more than 32 bit to the right) and the exponent difference. If the exponent difference is larger than expected than it sets all the shifters' enable to high, thus enabling all shifters. Otherwise it reads the last 5 bits of the exponent difference and sends them as the enable string.

\subsection{Re-arranger}
The exponents of the numbers need to be equal in order for the significands to be passed to the adder. To do that, we first need to find the difference of their exponent and shift the smaller exponent number to the right. So we clearly need a distinction based on the exponent. The \textit{Re-arranger} module takes 2 numbers as the base number(\textit{A}, \textit{B}) and 2 other decider numbers(\textit{P}, \textit{Q}) and re-arrange the number based on the decider numbers. It outputs 2 numbers - \textit{smaller} and \textit{larger}. If $P > Q$ then $\textrm{smaller} = A$ and $\textrm{larger} = B$. The alternative case happens when $P < Q$.\\

This is achieved by using a subtractor circuit as a comparator and comparing the \textit{deciders}. Then the comparison result is fed into 2 multiplexers that finally re-arrange the \textit{base} numbers and output \textit{smaller} and \textit{larger}

\subsection{Priority Encoder}
The priority encoder IC (74148) is only available for 8 to 3 line. But in order to normalize the number we needed priority encoders of size 32 bits (More details can be found in Section \ref{normalizer_section}). So we had to extend the basic 74148 IC. Moreover, the 74148 IC has active low inputs. We had to convert it to be used as active high input

\subsection{Normalization}\label{normalizer_section}
After addition the sum could become denormalized. In that case we have to normalize the result. Let's say the sum looks like this:  $d_1d_0.d_{-1}d_{-2}...d_{-20}$. Then the normalization process can be described in 3 cases -
\begin{description}
	\item[\boldmath{$d_1d_0=01$}] The number is already normalized
	\item[\boldmath{$d_1d_0=1\times$}] Shift the number 1 bit to the right (hence increment the exponent)
	\item[\boldmath{$d_1d_0=00$}] The number needs to be left shifted to bring a 1 after the radix point to the front of the number
\end{description}

The last case is a little different than the other cases since it requires finding the first 1 after the radix point when scanned from left to right. If the first 1 is found at position $d_{-n}$ than the number has to be shifted $n$ bits to the left. Note that in this example, $d_i = 0;\ \forall i < n$. The bits to the right of the first 1 do not matter. So it is clear that the first 1 has \textit{more priority} than the other 1s that follow. And we also want the position of the first 1 in binary so that this can be directly fed into the enables of the shifters as described in Section \ref{shifter_section}.This process can be done by using a priority encoder
\end{document}
