\documentclass[14pt]{article}

\begin{document}

\section{Introduction}
A floating point number is a number that has a decimal point and thus can store a fractional value. These numbers are stored differently than integers because to store a floating point number there are mainly 2 challenges. First of all, there is a challenge of storing the integer part and also storing the fractional part, hence more memory. Secondly, there are infinitely many floating point numbers even in a finite range, for example $[0, 1]$. So the floating point representation has to be clever enough to allow floating point numbers in a large range, as well as support good enough precision.\\\\

The floating point number representation uses the scientific notation of numbers. It has 3 parts - sign, significand and exponent. There are many different standards that decide how many bits each of these segments should store.\\
The \textit{IEEE 754} standard specifies that there should be 1 sign bit, 8 exponent bits and 23 significand bits.\\
The exponent is not directly stored, rather it is \textit{biased} first by adding a bias to the actual exponent and than store that in memory. The significance of this process is to make the exponent unsigned, thus allowing easier circuitry to deal with the comparison of exponents of 2 numbers. The bias is chosen to be $2^{n-1}-1$ where $n$ is the number of bits in the exponent field.\\
In the scientific notation there is always a 1 in front of the radix point unless the number is 0. So storing that 1 is redundant, hence the significand bits always store the fractional part.

So the overall representation looks like: 
$$(-1)^{\textrm{sign}}\times(1 + \textrm{significand})\times2^{\textrm{exponent}-\textrm{bias}}$$
Here the \textit{exponent} portion represents the exponent stored in memory.\\\\

This representation has the power of encapsulating large range due to the use of exponents. On the other hand it can store numbers in great precision as effective exponents can be negative, and thus indicate really small numbers. But it should be kept in mind that there can be scenarios, specially for larger exponents, where the exact floating point number can not be stored. In those cases the memory stores the nearest floating point number.

\pagebreak

\section{Problem Specification}
The assignment asked to create a floating point adder circuit that takes 2 floating point numbers and calculates their sum, and also notifies if there was any overflow or underflow. The representation was defined in the following manner- \\

{
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Sign} & \textbf{Exponent} & \textbf{Significand}\\
		\hline
		1 bit & 11 bits & 20 bits\\
		\hline
	\end{tabular}\par
}

\section{Comprehensive Design Description}
Each high level module and how they work is listed below

\subsection{Multiplexers}
There are several multiplexer circuit each working with different input sizes. The multiplexers that were required for this assignment are - $5\times1$, $8\times1$, $28\times1$, $32\times1$. They were created by chaining several $74157$ MUX ICs.

\subsection{Shifters}
In order to shift the numbers we needed different kind of shifters for both direction. In normalization and also in exponent-equalization, the numbers needed to be shifted by arbitrary amount. So shifters that can support arbitrary amount shifting were required.\\

Instead of making all possible shifters (1 bit shifter, 2 bit shifter, 3 bit shifter and so on..), the design was cleverly crafted so that there are lesser number of ICs used. Only 5 different shifters were created (1, 2, 4, 8 and 16). Each of them having 2 inputs - \textit{the number} and \textit{enable}. They are designed so that when the \textit{enable} is set to 1, the number is shifted by the amount specified by the module, otherwise the number is not changed and passed to the output. This \textit{enable} feature was achieved by introducing a MUX in the output so that when \textit{enable} is 1, the shifted number is sent to the output, otherwise the original number is sent to the output.\\

Now that the fixed amount of shifters (that can only shift by an amount that is a whole power of 2) are ready, we can finally create arbitrary shifters. The arbitrary right shifter (same logic for left shifter) takes 2 inputs - \textit{the number to shift} and \textit{the shift amount}. Since the shift amount is specified by a binary number, we can leverage the fact that in a binary number, each bit corresponds to the availability of a certain power of 2. So connecting each bit to the corresponding shifter's enable and chaining such shifters will suffice to shift by any arbitrary amount.

\subsection{Re-arranger}
The exponents of the numbers need to be equal in order for the significands to be passed to the adder. To do that, we first need to find the difference of their exponent and shift the smaller exponent number to the right. So we clearly need a distinction based on the exponent. The \textit{Re-arranger} module takes 2 numbers as the base number(\textit{A}, \textit{B}) and 2 other decider numbers(\textit{P}, \textit{Q}) and re-arrange the number based on the decider numbers. It outputs 2 numbers - \textit{smaller} and \textit{larger}. If $P > Q$ then $\textrm{smaller} = A$ and $\textrm{larger} = B$. The alternative case happens when $P < Q$.\\

This is achieved by using a subtractor circuit as a comparator and comparing the \textit{deciders}. Then the comparison result is fed into 2 multiplexers that finally re-arrange the \textit{base} numbers and output \textit{smaller} and \textit{larger}

\end{document}
